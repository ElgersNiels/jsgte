Dear Cesar and Alfonso,

thanks for your emails. By "single point of truth" I mean
one should store information where it belongs so that one
avoids duplication that then needs to be kept consistent.

My point was that MOVES should be associated with
information sets, but I think information sets should be
objects of their own right.

I had a rather clean way of storing game tree in a C program
where the most important definition is in the C header file

https://github.com/stengel/ecta2002/blob/master/treedef.h

and has 4 basic "classes" if you like, namely structures

    node  
    iset
    move
    outcome

where the corresponding capital letters

    Node
    Iset
    Move
    Outcome 

are pointers to these structures, which in C can be both
pointers to individual structures as well as ARRAYS of them.
You will see later in the file 

    /* ------------- global variables ------------------------------------- */
    /* game tree                                    */
    extern  Node    nodes;          /* nodes of game tree   */
    extern  Node    root;           /* &nodes[ROOT]         */
    extern  Iset    isets;          /* information sets     */
    extern  Move    moves;          /* moves & sequences    */
    extern  Outcome outcomes;       /* outcomes             */

but in fact there is no reason to put all these things into
arrays, they could equally be in linked lists or even in the
tree itself which you have to traverse somehow.

The tree is a set of nodes which are of the form

    struct node
        {
        Bool        terminal;       /* 0: decision node / 1: terminal node  */
        Iset        iset;           /* which information set                */
        Node        father;         /* node closer to root                  */
        Move        reachedby;      /* move of edge from father             */
        Outcome     outcome;        /* which outcome                        */

        /* will be generated by  genseqin()                                 */
        Move        defseq[PLAYERS];/* seq defd by node for each player     */
        };

so you see for each node you should know to which
information set it belongs, what its father is, by which
move it is reach from its father, and what outcome it is
(normally only relevant if the node is terminal).
There is also a tuple of moves, one for each player
(including chance) where `defseq[pl]` means the LAST
move on the path to the current root by player `pl`.


    struct iset     /* information set      */
        {
        /* given                    */
        int         player;         /* 0: chance player                     */
        int         nmoves;
        Move        move0;
        /* autoname possible                                                */
        char        name[NAMECHARS];        /* name of iset                 */
        /* will be generated                                                */
        Move        seqin;          /* sequence leading to that iset        */
        /* for NF computation                                               */
        int         ncontin;        /* how many strategy-type continuations */
        int         prefact;        /* multiplyer for later parallel isets  */
        };

    struct move   /* move, also sequence ending in that move        */
        {
        Iset        atiset;         /* where this move emanates from        */
        Rat         behavprob;      /* behavior probability                 */
        Rat         realprob;       /* realization probability              */
        int         redsfcol;       /* column of reduced sequence form      */
        /* for NF computation                                               */
        int         ncompat;        /* number of compatible partial strats  */
        int         offset;         /* number of partial strats for moves   */
                    /* to the right of this at same iset    */
        };

    struct outcome
        {
        Payvec      pay;
        Node        whichnode;
        };

    /* sizes of these arrays                                                */
    /* first ILLEGAL pointer at the end of array nodes      */
    extern  Node lastnode;
    /* isets for player  pl:  firstiset[pl] ... firstiset[pl+1]-1       */
    extern  Iset firstiset[PLAYERS+1];
    /* moves for player  pl:  firstmove[pl] ... firstmove[pl+1]-1       */
    extern  Move firstmove[PLAYERS+1];
    /* first ILLEGAL pointer at end of array outcomes */
    extern  Outcome lastoutcome;

    /* number of sequences for each player          */
    extern  int nseqs[PLAYERS];     
    /* number of information sets for each player   */
    extern  int nisets[PLAYERS];

    /* ----------- generating derived tree data -------------------- */
    /* checks perfect recall, returns 1 if there is a problem 
     * sets  sequence triples leading to nodes & seqin for isets
     * sets  nseqs[], nisets[]
     */
    Bool genseqin(void);

    /* normalize maximum payoff to players to -1
     * bprint:  announce current max payoffs to stdout
     */
    void maxpayminusone(Bool bprint);

    /* names  isets  using an1[pl]..an2[pl]
     * assume nisets[] set  by  genseqin()
     */
    void autoname(void);

    /* ----------- output routines --------------------------------- */
    /*
     * convert  c  of player  pl  to string  s
     * c == NULL:  s = "*".  c == empty sequence: s="()"
     * o/w  iset's name + move no
     * returns length of string.  s must be long enough
     */
    int movetoa (Move c, int pl, char *s);

    /* convert sequence  seq  of player  pl  to string  s  
     * c == NULL:  s = "*".  c == empty sequence: s="." 
     * returns length of string.  s must be long enough
     */
    int seqtoa (Move seq, int pl, char *s);

    /* prints the raw tree data                     */
    void rawtreeprint(void);

